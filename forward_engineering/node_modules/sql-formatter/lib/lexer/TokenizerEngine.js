"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token2 = require("./token");

var _regexUtil = require("./regexUtil");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TokenizerEngine = /*#__PURE__*/function () {
  // The input SQL string to process
  // Current position in string
  function TokenizerEngine(rules) {
    _classCallCheck(this, TokenizerEngine);

    _defineProperty(this, "rules", void 0);

    _defineProperty(this, "input", '');

    _defineProperty(this, "index", 0);

    this.rules = rules;
  }
  /**
   * Takes a SQL string and breaks it into tokens.
   * Each token is an object with type and value.
   *
   * @param {string} input - The SQL string
   * @returns {Token[]} output token stream
   */


  _createClass(TokenizerEngine, [{
    key: "tokenize",
    value: function tokenize(input) {
      this.input = input;
      this.index = 0;
      var tokens = [];
      var token; // Keep processing the string until end is reached

      while (this.index < this.input.length) {
        // skip any preceding whitespace
        var precedingWhitespace = this.getWhitespace();

        if (this.index < this.input.length) {
          // Get the next token and the token type
          token = this.getNextToken(token);

          if (!token) {
            throw new Error("Parse error: Unexpected \"".concat(input.slice(this.index, 100), "\""));
          }

          tokens.push(_objectSpread(_objectSpread({}, token), {}, {
            precedingWhitespace: precedingWhitespace
          }));
        }
      }

      return tokens;
    }
  }, {
    key: "getWhitespace",
    value: function getWhitespace() {
      _regexUtil.WHITESPACE_REGEX.lastIndex = this.index;

      var matches = _regexUtil.WHITESPACE_REGEX.exec(this.input);

      if (matches) {
        // Advance current position by matched whitespace length
        this.index += matches[0].length;
        return matches[0];
      }

      return undefined;
    }
  }, {
    key: "getNextToken",
    value: function getNextToken(previousToken) {
      return this.matchToken(_token2.TokenType.BLOCK_COMMENT) || this.matchToken(_token2.TokenType.LINE_COMMENT) || this.matchToken(_token2.TokenType.QUOTED_IDENTIFIER) || this.matchToken(_token2.TokenType.NUMBER) || this.matchReservedWordToken(previousToken) || this.matchPlaceholderToken(_token2.TokenType.NAMED_PARAMETER) || this.matchPlaceholderToken(_token2.TokenType.QUOTED_PARAMETER) || this.matchPlaceholderToken(_token2.TokenType.NUMBERED_PARAMETER) || this.matchPlaceholderToken(_token2.TokenType.POSITIONAL_PARAMETER) || this.matchToken(_token2.TokenType.VARIABLE) || this.matchToken(_token2.TokenType.STRING) || this.matchToken(_token2.TokenType.IDENTIFIER) || this.matchToken(_token2.TokenType.DELIMITER) || this.matchToken(_token2.TokenType.COMMA) || this.matchToken(_token2.TokenType.OPEN_PAREN) || this.matchToken(_token2.TokenType.CLOSE_PAREN) || this.matchToken(_token2.TokenType.OPERATOR) || this.matchToken(_token2.TokenType.ASTERISK);
    }
  }, {
    key: "matchPlaceholderToken",
    value: function matchPlaceholderToken(tokenType) {
      if (tokenType in this.rules) {
        var _token = this.matchToken(tokenType);

        var tokenRule = this.rules[tokenType];

        if (_token) {
          if (tokenRule !== null && tokenRule !== void 0 && tokenRule.key) {
            return _objectSpread(_objectSpread({}, _token), {}, {
              key: tokenRule.key(_token.text)
            });
          }

          return _token; // POSITIONAL_PARAMETER does not have a key transform function
        }
      }

      return undefined;
    }
  }, {
    key: "matchReservedWordToken",
    value: function matchReservedWordToken(previousToken) {
      // A reserved word cannot be preceded by a '.'
      // this makes it so in "mytable.from", "from" is not considered a reserved word
      if ((previousToken === null || previousToken === void 0 ? void 0 : previousToken.text) === '.') {
        return undefined;
      } // prioritised list of Reserved token types


      return this.matchToken(_token2.TokenType.CASE) || this.matchToken(_token2.TokenType.END) || this.matchToken(_token2.TokenType.BETWEEN) || this.matchToken(_token2.TokenType.LIMIT) || this.matchToken(_token2.TokenType.RESERVED_COMMAND) || this.matchToken(_token2.TokenType.RESERVED_SELECT) || this.matchToken(_token2.TokenType.RESERVED_SET_OPERATION) || this.matchToken(_token2.TokenType.RESERVED_DEPENDENT_CLAUSE) || this.matchToken(_token2.TokenType.RESERVED_JOIN) || this.matchToken(_token2.TokenType.RESERVED_PHRASE) || this.matchToken(_token2.TokenType.AND) || this.matchToken(_token2.TokenType.OR) || this.matchToken(_token2.TokenType.XOR) || this.matchToken(_token2.TokenType.RESERVED_FUNCTION_NAME) || this.matchToken(_token2.TokenType.RESERVED_KEYWORD);
    } // Shorthand for `match` that looks up regex from rules

  }, {
    key: "matchToken",
    value: function matchToken(tokenType) {
      var rule = this.rules[tokenType];

      if (!rule) {
        return undefined;
      }

      return this.match({
        type: tokenType,
        regex: rule.regex,
        transform: rule.value
      });
    } // Attempts to match RegExp at current position in input

  }, {
    key: "match",
    value: function match(_ref) {
      var type = _ref.type,
          regex = _ref.regex,
          transform = _ref.transform;
      regex.lastIndex = this.index;
      var matches = regex.exec(this.input);

      if (matches) {
        var matchedToken = matches[0];
        var outToken = {
          type: type,
          raw: matchedToken,
          text: transform ? transform(matchedToken) : matchedToken,
          start: this.index,
          end: this.index + matchedToken.length
        }; // Advance current position by matched token length

        this.index += matchedToken.length;
        return outToken;
      }

      return undefined;
    }
  }]);

  return TokenizerEngine;
}();

exports["default"] = TokenizerEngine;
module.exports = exports.default;
//# sourceMappingURL=TokenizerEngine.js.map